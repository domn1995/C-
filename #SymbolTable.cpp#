#include "symbolTable.h"

// // // // // // // // // // // // // // // // // // // //
//
// Some sample void * printing routines.   User shoud supply their own.
//

void pointerPrintAddr(void *data)
{
    printf("0x%016llx ", (unsigned long long int)(data));
}

void pointerPrintLongInteger(void *data)
{
    printf("%18lld ", (unsigned long long int)(data));
}

void pointerPrintStr(void *data)
{
    printf("%s ", (char *)(data));
}

// // // // // // // // // // // // // // // // // // // //
//
// Class: Scope
//

Scope::Scope(std::string newname) {
    name = newname;
    debugFlg = false;
}


Scope::~Scope() {
}


void Scope::debug(bool state) {
    debugFlg = state;
}


void Scope::print(void (*printData)(void *)) {
    printf("Scope: %-15s -----------------\n", name.c_str());
    for (std::map<std::string , void *>::iterator it=symbols.begin(); it!=symbols.end(); it++) {
	printf("%20s: ", (it->first).c_str());
	printData(it->second);
	printf("\n");
    }

}


void Scope::applyToAll(void (*action)(std::string , void *)) {
    for (std::map<std::string , void *>::iterator it=symbols.begin(); it!=symbols.end(); it++) {
	action(it->first, it->second);
    }
}


// returns true if insert was successful and false if symbol already in this scope
bool Scope::insert(std::string sym, void *ptr) {
    if (symbols.find(sym) == symbols.end()) {
	if (debugFlg) printf("DEBUG(Scope): insert in \"%s\" the symbol \"%s\".\n", name.c_str(), sym.c_str());
	symbols[sym] = ptr;
	return true;
    }
    else {
	if (debugFlg) printf("DEBUG(Scope): insert in \"%s\" the symbol \"%s\" but symbol already there!\n", name.c_str(), sym.c_str());
	return false;
    }
}

void *Scope::lookup(std::string sym) {
    if (symbols.find(sym) != symbols.end()) {
	if (debugFlg) printf("DEBUG(Scope): lookup in \"%s\" the symbol \"%s\" and found it.\n", name.c_str(), sym.c_str());
	return symbols[sym];
    }
    else {
	if (debugFlg) printf("DEBUG(Scope): lookup in \"%s\" the symbol \"%s\" and did NOT find it.\n", name.c_str(), sym.c_str());
	return NULL;
    }
}

bool Scope::debugFlg;




// // // // // // // // // // // // // // // // // // // //
//
// Class: SymbolTable
//
//  This is a stack of scopes that represents a symbol table
//

SymbolTable::SymbolTable()
{
    enter((std::string )"Global");
    debugFlg = false;
}


void SymbolTable::debug(bool state)
{
    debugFlg = state;
}


// Returns the number of scopes in the symbol table
int SymbolTable::depth()
{
    return stack.size();
}


// print all scopes using data printing func
void SymbolTable::print(void (*printData)(void *))
{
    printf("===========  Symbol Table  ===========\n");
    for (std::vector<Scope *>::iterator it=stack.begin(); it!=stack.end(); it++) {
	(*it)->print(printData);
    }
    printf("===========  ============  ===========\n");
}


void SymbolTable::applyToAllGlobal(void (*action)(std::string , void *))
{
    stack[0]->applyToAll(action);
}


// Enter a scope
void SymbolTable::enter(std::string name)
{
    if (debugFlg) printf("DEBUG(SymbolTable): enter scope \"%s\".\n", name.c_str());
    stack.push_back(new Scope(name));
}


// Leave a scope (not allowed to leave global)
void SymbolTable::leave()
{
    if (debugFlg) printf("DEBUG(SymbolTable): leave scope \"%s\".\n", (stack.back()->scopeName()).c_str());
    if (stack.size()>1) {
	delete stack.back();
	stack.pop_back();
    }
    else {
	printf("ERROR(SymbolTable): You cannot leave global scope.  Number of scopes: %d.\n", (int)stack.size());
    }
}


// Lookup a symbol anywhere in the stack of scopes
// Returns NULL if symbol not found, otherwise it returns the stored void * associated with the symbol
void * SymbolTable::lookup(std::string sym)
{
    void *data;

    for (std::vector<Scope *>::reverse_iterator it=stack.rbegin(); it!=stack.rend(); it++) {
	data = (*it)->lookup(sym);
	if (data!=NULL) break;
    }
    if (debugFlg) printf("DEBUG(SymbolTable): 